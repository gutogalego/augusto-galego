---
description: Advanced UI animation for creating performant, accessible micro-interactions in React/Next.js applications. Provides spring-based physics systems, SVG path animations, and gesture controls following industry best practices from leading design engineers. Includes adaptive performance optimization that responds to device capabilities, battery levels, and user accessibility preferences. Ensures 60fps animations using compositor-friendly properties while respecting prefers-reduced-motion settings. Perfect for modern web apps requiring professional-grade animations that enhance UX without compromising performance or accessibility standards.
alwaysApply: false
---
# Advanced Animation Guidelines for UI Interfaces

## Animation Design Philosophy

### Core Principles

- **Purpose**: Every animation must have a clear purpose - guide, inform, delight, or provide feedback
- **Naturalness**: Animations should follow natural physical principles (easing, momentum, gravity)
- **Consistency**: Maintain consistent patterns of timing, easing, and behavior throughout the application
- **Performance First**: Prioritize 60fps and optimization for low-performance devices
- **Accessibility**: Respect user preferences (prefers-reduced-motion)
- **Interruptibility**: Animations must be interruptible and responsive to new interactions
- **Contextuality**: Adapt animations based on device, connection, and user preferences

### Leading Design Engineers' Practices

#### Josh Comeau - Natural Animation Principles

```typescript
// Easing curves based on real physics
const NATURAL_EASING = {
  // Physical spring simulation
  spring: [0.25, 0.46, 0.45, 0.94],
  // Movement with gravity
  gravity: [0.55, 0.055, 0.675, 0.19],
  // Smooth and natural bounce
  bounce: [0.68, -0.55, 0.265, 1.55],
  // Organic entrance
  organic: [0.23, 1, 0.32, 1]
} as const;

// Duration system based on distance
const getDynamicDuration = (distance: number, baseSpeed = 300) => {
  return Math.max(150, Math.min(800, distance / baseSpeed * 1000));
};
```

#### Emil Kowalski - Elegant Micro-interactions

```typescript
// Instant visual feedback with natural physics
const useInstantFeedback = () => {
  const [isPressed, setIsPressed] = useState(false);

  const pressVariants = {
    pressed: {
      scale: 0.96,
      transition: { type: "spring", stiffness: 400, damping: 17 }
    },
    released: {
      scale: 1,
      transition: { type: "spring", stiffness: 400, damping: 17 }
    }
  };

  return { isPressed, setIsPressed, pressVariants };
};

// Loading states with personality
const LoadingStates = {
  skeleton: {
    opacity: [0.4, 0.8, 0.4],
    transition: {
      duration: 1.5,
      repeat: Infinity,
      ease: "easeInOut"
    }
  },
  pulse: {
    scale: [1, 1.05, 1],
    transition: {
      duration: 2,
      repeat: Infinity,
      ease: "easeInOut"
    }
  }
};
```

#### Rauno Freiberg - Contextual Transitions

```typescript
// Context-based animation system
const useContextualAnimations = () => {
  const [connectionSpeed] = useNetworkSpeed();
  const [devicePower] = useDevicePower();
  const [batteryLevel] = useBattery();

  const getAnimationConfig = useCallback(() => {
    // Reduce animations on low battery devices
    if (batteryLevel < 0.2) {
      return { duration: 0, type: "tween" };
    }

    // Adapt based on device performance
    if (devicePower === 'low') {
      return {
        duration: 0.2,
        type: "tween",
        ease: "easeOut"
      };
    }

    // Full configuration for powerful devices
    return {
      type: "spring",
      stiffness: 400,
      damping: 25,
      mass: 0.8
    };
  }, [connectionSpeed, devicePower, batteryLevel]);

  return { getAnimationConfig };
};
```

### Timing and Easing

```typescript
// Recommended durations
const ANIMATION_DURATIONS = {
  micro: 150,      // Hover states, button feedback
  short: 300,      // Modals, dropdowns, tooltips
  medium: 500,     // Page transitions, complex state changes
  long: 800,       // Hero animations, loading sequences
  extended: 1200   // Storytelling, onboarding
} as const;

// Optimized easing curves
const EASING_CURVES = {
  // Smooth entrance
  easeOut: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
  // Smooth exit
  easeIn: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)',
  // Natural transition
  easeInOut: 'cubic-bezier(0.645, 0.045, 0.355, 1)',
  // Smooth bounce
  easeOutBack: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
  // Quick snap
  easeOutQuint: 'cubic-bezier(0.23, 1, 0.32, 1)'
} as const;
```

## SVG Animations

### Structure and Optimization

```typescript
// SVG optimization for animations
interface OptimizedSVGProps {
  viewBox: string;
  preserveAspectRatio?: string;
  className?: string;
  'aria-hidden'?: boolean;
}

const OptimizedSVG = ({
  viewBox,
  preserveAspectRatio = "xMidYMid meet",
  className,
  children,
  ...props
}: OptimizedSVGProps) => (
  <svg
    viewBox={viewBox}
    preserveAspectRatio={preserveAspectRatio}
    className={className}
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    {children}
  </svg>
);
```

### Advanced SVG Animation Techniques

#### 1. Path Drawing Animation

```typescript
import { useEffect, useRef } from 'react';

const AnimatedPath = ({
  pathData,
  duration = 2000,
  delay = 0
}: {
  pathData: string;
  duration?: number;
  delay?: number;
}) => {
  const pathRef = useRef<SVGPathElement>(null);

  useEffect(() => {
    const path = pathRef.current;
    if (!path) return;

    const length = path.getTotalLength();

    // Initial setup
    path.style.strokeDasharray = `${length}`;
    path.style.strokeDashoffset = `${length}`;
    path.style.transition = 'none';

    // Trigger animation
    setTimeout(() => {
      path.style.transition = `stroke-dashoffset ${duration}ms cubic-bezier(0.25, 0.46, 0.45, 0.94)`;
      path.style.strokeDashoffset = '0';
    }, delay);

    return () => {
      path.style.transition = 'none';
    };
  }, [duration, delay]);

  return (
    <path
      ref={pathRef}
      d={pathData}
      stroke="currentColor"
      strokeWidth="2"
      fill="none"
      strokeLinecap="round"
      strokeLinejoin="round"
    />
  );
};
```

#### 2. Advanced Morphing

```typescript
import { gsap } from 'gsap';
import { MorphSVGPlugin } from 'gsap/MorphSVGPlugin';

gsap.registerPlugin(MorphSVGPlugin);

const MorphingIcon = ({
  isActive,
  paths
}: {
  isActive: boolean;
  paths: [string, string];
}) => {
  const pathRef = useRef<SVGPathElement>(null);

  useEffect(() => {
    if (!pathRef.current) return;

    gsap.to(pathRef.current, {
      morphSVG: isActive ? paths[1] : paths[0],
      duration: 0.4,
      ease: "power2.inOut"
    });
  }, [isActive, paths]);

  return (
    <svg viewBox="0 0 24 24" className="w-6 h-6">
      <path
        ref={pathRef}
        d={paths[0]}
        fill="currentColor"
      />
    </svg>
  );
};
```

## Motion (Framer Motion)

### Advanced Configuration

```typescript
import {
  motion,
  AnimatePresence,
  useAnimation,
  useInView,
  useScroll,
  useTransform,
  MotionConfig,
  LazyMotion,
  domAnimation,
  m
} from 'framer-motion';

// Optimized global configuration with LazyMotion
const MotionProvider = ({ children }: { children: React.ReactNode }) => (
  <LazyMotion features={domAnimation} strict>
    <MotionConfig
      transition={{
        type: "spring",
        stiffness: 300,
        damping: 30,
        mass: 0.8
      }}
      reducedMotion="user"
    >
      {children}
    </MotionConfig>
  </LazyMotion>
);

// Optimized component with m (lazy version)
const OptimizedComponent = () => (
  <m.div
    initial={{ opacity: 0, y: 20 }}
    animate={{ opacity: 1, y: 0 }}
    transition={{ duration: 0.4, ease: [0.25, 0.46, 0.45, 0.94] }}
  >
    Content
  </m.div>
);
```

### Advanced Variants and Orchestration 2024-2025

```typescript
// Hierarchical variant system with advanced orchestration
const containerVariants = {
  hidden: {
    opacity: 0,
    transition: {
      staggerChildren: 0.05,
      staggerDirection: -1,
      when: "afterChildren"
    }
  },
  visible: {
    opacity: 1,
    transition: {
      staggerChildren: 0.08,
      delayChildren: 0.1,
      when: "beforeChildren",
      type: "spring",
      stiffness: 400,
      damping: 25
    }
  }
};

// Variants with natural spring-based physics
const itemVariants = {
  hidden: {
    y: 60,
    opacity: 0,
    scale: 0.8,
    rotateX: -15,
    transition: {
      type: "spring",
      stiffness: 300,
      damping: 30
    }
  },
  visible: {
    y: 0,
    opacity: 1,
    scale: 1,
    rotateX: 0,
    transition: {
      type: "spring",
      stiffness: 400,
      damping: 25,
      mass: 0.8
    }
  }
};

// Conditional variants based on context
const adaptiveVariants = {
  hidden: (custom: { isReducedMotion: boolean; isMobile: boolean }) => ({
    opacity: 0,
    y: custom.isReducedMotion ? 0 : (custom.isMobile ? 20 : 40),
    transition: {
      duration: custom.isReducedMotion ? 0 : (custom.isMobile ? 0.3 : 0.5)
    }
  }),
  visible: (custom: { isReducedMotion: boolean; isMobile: boolean }) => ({
    opacity: 1,
    y: 0,
    transition: {
      type: custom.isReducedMotion ? "tween" : "spring",
      stiffness: custom.isMobile ? 200 : 300,
      damping: custom.isMobile ? 20 : 25
    }
  })
};
```

### Micro-interactions and Advanced Gestures

```typescript
import { useDragControls, PanInfo, useMotionValue, useTransform } from 'framer-motion';

// Hook for intelligent micro-interactions
const useSmartInteractions = () => {
  const [prefersReducedMotion] = useMediaQuery('(prefers-reduced-motion: reduce)');
  const [isTouchDevice] = useMediaQuery('(hover: none)');

  const getInteractionConfig = useCallback(() => ({
    hover: prefersReducedMotion ? {} : {
      scale: isTouchDevice ? 1 : 1.02,
      transition: { type: "spring", stiffness: 400, damping: 25 }
    },
    tap: {
      scale: 0.98,
      transition: { type: "spring", stiffness: 600, damping: 30 }
    }
  }), [prefersReducedMotion, isTouchDevice]);

  return { getInteractionConfig, prefersReducedMotion, isTouchDevice };
};

// Advanced card component with gestures
const AdvancedDraggableCard = ({
  onSwipe,
  children
}: {
  onSwipe?: (direction: 'left' | 'right') => void;
  children: React.ReactNode;
}) => {
  const dragControls = useDragControls();
  const [isDragging, setIsDragging] = useState(false);
  const { getInteractionConfig } = useSmartInteractions();

  const x = useMotionValue(0);
  const rotate = useTransform(x, [-200, 0, 200], [-15, 0, 15]);
  const opacity = useTransform(x, [-200, -100, 0, 100, 200], [0.5, 0.8, 1, 0.8, 0.5]);

  const handleDragEnd = (event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {
    const threshold = 100;
    const velocity = Math.abs(info.velocity.x);
    const offset = info.offset.x;

    if (velocity > 500 || Math.abs(offset) > threshold) {
      const direction = offset > 0 ? 'right' : 'left';
      onSwipe?.(direction);

      // Animate out
      animate(x, direction === 'right' ? 300 : -300, {
        type: "spring",
        stiffness: 300,
        damping: 30
      });
    } else {
      // Snap back
      animate(x, 0, {
        type: "spring",
        stiffness: 400,
        damping: 40
      });
    }
  };

  return (
    <motion.div
      drag="x"
      dragControls={dragControls}
      dragConstraints={{ left: 0, right: 0 }}
      dragElastic={0.1}
      style={{ x, rotate, opacity }}
      onDragStart={() => setIsDragging(true)}
      onDragEnd={handleDragEnd}
      whileHover={getInteractionConfig().hover}
      whileTap={getInteractionConfig().tap}
      className={`relative p-6 bg-white rounded-xl shadow-lg cursor-grab ${
        isDragging ? 'cursor-grabbing z-10' : ''
      }`}
    >
      {children}

      {/* Visual swipe indicators */}
      <motion.div
        className="absolute inset-y-0 left-4 flex items-center"
        animate={{ opacity: isDragging ? 1 : 0 }}
      >
        <div className="w-2 h-8 bg-green-400 rounded-full" />
      </motion.div>

      <motion.div
        className="absolute inset-y-0 right-4 flex items-center"
        animate={{ opacity: isDragging ? 1 : 0 }}
      >
        <div className="w-2 h-8 bg-red-400 rounded-full" />
      </motion.div>
    </motion.div>
  );
};

// Button with simulated haptic feedback
const HapticButton = ({
  onClick,
  children,
  variant = 'primary'
}: {
  onClick: () => void;
  children: React.ReactNode;
  variant?: 'primary' | 'secondary';
}) => {
  const { getInteractionConfig } = useSmartInteractions();

  const handleClick = () => {
    // Simulate visual haptic feedback
    if (navigator.vibrate) {
      navigator.vibrate(10);
    }
    onClick();
  };

  return (
    <motion.button
      onClick={handleClick}
      whileHover={getInteractionConfig().hover}
      whileTap={getInteractionConfig().tap}
      className={`px-6 py-3 rounded-lg font-medium transition-colors ${
        variant === 'primary'
          ? 'bg-blue-500 text-white hover:bg-blue-600'
          : 'bg-gray-200 text-gray-900 hover:bg-gray-300'
      }`}
    >
      {children}
    </motion.button>
  );
};
```

## Performance and Optimization

### Performance Monitoring

```typescript
// Hook for FPS monitoring
const usePerformanceMonitor = () => {
  const [fps, setFps] = useState(60);
  const [isLowPerformance, setIsLowPerformance] = useState(false);
  const frameCountRef = useRef(0);
  const lastTimeRef = useRef(performance.now());

  useEffect(() => {
    let animationId: number;

    const measureFPS = () => {
      frameCountRef.current++;
      const currentTime = performance.now();

      if (currentTime - lastTimeRef.current >= 1000) {
        const currentFPS = frameCountRef.current;
        setFps(currentFPS);
        setIsLowPerformance(currentFPS < 30);

        frameCountRef.current = 0;
        lastTimeRef.current = currentTime;
      }

      animationId = requestAnimationFrame(measureFPS);
    };

    measureFPS();

    return () => {
      cancelAnimationFrame(animationId);
    };
  }, []);

  return { fps, isLowPerformance };
};

// Adaptive component based on performance
const AdaptiveAnimation = ({
  children,
  fallback
}: {
  children: React.ReactNode;
  fallback?: React.ReactNode;
}) => {
  const { isLowPerformance } = usePerformanceMonitor();
  const [reducedMotion] = useMediaQuery('(prefers-reduced-motion: reduce)');

  if (reducedMotion || isLowPerformance) {
    return <>{fallback || children}</>;
  }

  return <>{children}</>;
};
```

### Resource Optimization

```typescript
// Lazy loading for heavy animations
const LazyAnimation = lazy(() => import('./HeavyAnimation'));

// Object pool for reuse
class ObjectPool<T> {
  private pool: T[] = [];
  private createFn: () => T;
  private resetFn: (obj: T) => void;

  constructor(createFn: () => T, resetFn: (obj: T) => void, initialSize = 10) {
    this.createFn = createFn;
    this.resetFn = resetFn;

    for (let i = 0; i < initialSize; i++) {
      this.pool.push(createFn());
    }
  }

  get(): T {
    return this.pool.pop() || this.createFn();
  }

  release(obj: T): void {
    this.resetFn(obj);
    this.pool.push(obj);
  }
}

// Debounce for event-based animations
const useAnimationDebounce = (callback: () => void, delay: number) => {
  const timeoutRef = useRef<NodeJS.Timeout>();

  return useCallback(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    timeoutRef.current = setTimeout(callback, delay);
  }, [callback, delay]);
};
```

## Accessibility in Animations

### Implementation of prefers-reduced-motion

```typescript
// Hook to detect reduced motion preference
const useReducedMotion = () => {
  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);

  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
    setPrefersReducedMotion(mediaQuery.matches);

    const handleChange = (event: MediaQueryListEvent) => {
      setPrefersReducedMotion(event.matches);
    };

    mediaQuery.addEventListener('change', handleChange);
    return () => mediaQuery.removeEventListener('change', handleChange);
  }, []);

  return prefersReducedMotion;
};

// Accessibility-respectful component
const AccessibleAnimation = ({
  children,
  fallback,
  respectMotionPreference = true
}: {
  children: React.ReactNode;
  fallback?: React.ReactNode;
  respectMotionPreference?: boolean;
}) => {
  const prefersReducedMotion = useReducedMotion();

  if (respectMotionPreference && prefersReducedMotion) {
    return <>{fallback || children}</>;
  }

  return <>{children}</>;
};

// Accessible variants for Framer Motion
const accessibleVariants = {
  hidden: (prefersReducedMotion: boolean) => ({
    opacity: 0,
    y: prefersReducedMotion ? 0 : 20,
    transition: {
      duration: prefersReducedMotion ? 0 : 0.3
    }
  }),
  visible: (prefersReducedMotion: boolean) => ({
    opacity: 1,
    y: 0,
    transition: {
      duration: prefersReducedMotion ? 0 : 0.3,
      ease: "easeOut"
    }
  })
};
```

## Behavioral Rules for Cursor IDE

### Component Declaration Rules

```typescript
// ✅ CORRECT: Use function declarations, not React.FC
function AnimatedButton({ onClick, children }: {
  onClick: () => void;
  children: React.ReactNode;
}) {
  return (
    <motion.button
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      onClick={onClick}
    >
      {children}
    </motion.button>
  );
}

// ❌ INCORRECT: Don't use React.FC
const AnimatedButton: React.FC<Props> = ({ onClick, children }) => {
  // ...
};
```

### Animation Implementation Rules

1. **Always use compositor-friendly properties**
   - Prefer `transform`, `opacity`, `filter`
   - Avoid `width`, `height`, `top`, `left`

2. **Implement reduced motion fallbacks**

   ```typescript
   const variants = {
     initial: { opacity: 0, y: prefersReducedMotion ? 0 : 20 },
     animate: { opacity: 1, y: 0 }
   };
   ```

3. **Use spring physics for natural movement**

   ```typescript
   const springConfig = {
     type: "spring",
     stiffness: 400,
     damping: 25,
     mass: 0.8
   };
   ```

4. **Optimize for performance**
   - Use `LazyMotion` for bundle size optimization
   - Implement object pooling for repeated animations
   - Monitor FPS and adapt accordingly

5. **Provide meaningful feedback**
   - Loading states should have personality
   - Micro-interactions should feel responsive
   - Error states should be clearly animated

### Code Organization Rules

1. **Separate animation logic from business logic**
2. **Create reusable animation hooks**
3. **Use consistent naming conventions**
4. **Document complex animation sequences**
5. **Test animations across different devices**

### Performance Thresholds

- **Target**: 60 FPS consistently
- **Acceptable**: 30 FPS minimum
- **Duration limits**:
  - Micro-interactions: 150ms
  - Transitions: 300ms
  - Complex sequences: 800ms max

### Accessibility Requirements

- Always respect `prefers-reduced-motion`
- Provide alternative feedback for animations
- Ensure animations don't interfere with screen readers
- Test with keyboard navigation
- Maintain focus management during animations

This comprehensive guide ensures animations are performant, accessible, and enhance user experience while following modern best practices and avoiding deprecated patterns like `React.FC`.

# Advanced Animation Guidelines for UI Interfaces

## Animation Design Philosophy

### Core Principles

- **Purpose**: Every animation must have a clear purpose - guide, inform, delight, or provide feedback
- **Naturalness**: Animations should follow natural physical principles (easing, momentum, gravity)
- **Consistency**: Maintain consistent patterns of timing, easing, and behavior throughout the application
- **Performance First**: Prioritize 60fps and optimization for low-performance devices
- **Accessibility**: Respect user preferences (prefers-reduced-motion)
- **Interruptibility**: Animations must be interruptible and responsive to new interactions
- **Contextuality**: Adapt animations based on device, connection, and user preferences

### Leading Design Engineers' Practices

#### Josh Comeau - Natural Animation Principles

```typescript
// Easing curves based on real physics
const NATURAL_EASING = {
  // Physical spring simulation
  spring: [0.25, 0.46, 0.45, 0.94],
  // Movement with gravity
  gravity: [0.55, 0.055, 0.675, 0.19],
  // Smooth and natural bounce
  bounce: [0.68, -0.55, 0.265, 1.55],
  // Organic entrance
  organic: [0.23, 1, 0.32, 1]
} as const;

// Duration system based on distance
const getDynamicDuration = (distance: number, baseSpeed = 300) => {
  return Math.max(150, Math.min(800, distance / baseSpeed * 1000));
};
```

#### Emil Kowalski - Elegant Micro-interactions

```typescript
// Instant visual feedback with natural physics
const useInstantFeedback = () => {
  const [isPressed, setIsPressed] = useState(false);

  const pressVariants = {
    pressed: {
      scale: 0.96,
      transition: { type: "spring", stiffness: 400, damping: 17 }
    },
    released: {
      scale: 1,
      transition: { type: "spring", stiffness: 400, damping: 17 }
    }
  };

  return { isPressed, setIsPressed, pressVariants };
};

// Loading states with personality
const LoadingStates = {
  skeleton: {
    opacity: [0.4, 0.8, 0.4],
    transition: {
      duration: 1.5,
      repeat: Infinity,
      ease: "easeInOut"
    }
  },
  pulse: {
    scale: [1, 1.05, 1],
    transition: {
      duration: 2,
      repeat: Infinity,
      ease: "easeInOut"
    }
  }
};
```

#### Rauno Freiberg - Contextual Transitions

```typescript
// Context-based animation system
const useContextualAnimations = () => {
  const [connectionSpeed] = useNetworkSpeed();
  const [devicePower] = useDevicePower();
  const [batteryLevel] = useBattery();

  const getAnimationConfig = useCallback(() => {
    // Reduce animations on low battery devices
    if (batteryLevel < 0.2) {
      return { duration: 0, type: "tween" };
    }

    // Adapt based on device performance
    if (devicePower === 'low') {
      return {
        duration: 0.2,
        type: "tween",
        ease: "easeOut"
      };
    }

    // Full configuration for powerful devices
    return {
      type: "spring",
      stiffness: 400,
      damping: 25,
      mass: 0.8
    };
  }, [connectionSpeed, devicePower, batteryLevel]);

  return { getAnimationConfig };
};
```

### Timing and Easing

```typescript
// Recommended durations
const ANIMATION_DURATIONS = {
  micro: 150,      // Hover states, button feedback
  short: 300,      // Modals, dropdowns, tooltips
  medium: 500,     // Page transitions, complex state changes
  long: 800,       // Hero animations, loading sequences
  extended: 1200   // Storytelling, onboarding
} as const;

// Optimized easing curves
const EASING_CURVES = {
  // Smooth entrance
  easeOut: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
  // Smooth exit
  easeIn: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)',
  // Natural transition
  easeInOut: 'cubic-bezier(0.645, 0.045, 0.355, 1)',
  // Smooth bounce
  easeOutBack: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
  // Quick snap
  easeOutQuint: 'cubic-bezier(0.23, 1, 0.32, 1)'
} as const;
```

## SVG Animations

### Structure and Optimization

```typescript
// SVG optimization for animations
interface OptimizedSVGProps {
  viewBox: string;
  preserveAspectRatio?: string;
  className?: string;
  'aria-hidden'?: boolean;
}

const OptimizedSVG = ({
  viewBox,
  preserveAspectRatio = "xMidYMid meet",
  className,
  children,
  ...props
}: OptimizedSVGProps) => (
  <svg
    viewBox={viewBox}
    preserveAspectRatio={preserveAspectRatio}
    className={className}
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    {children}
  </svg>
);
```

### Advanced SVG Animation Techniques

#### 1. Path Drawing Animation

```typescript
import { useEffect, useRef } from 'react';

const AnimatedPath = ({
  pathData,
  duration = 2000,
  delay = 0
}: {
  pathData: string;
  duration?: number;
  delay?: number;
}) => {
  const pathRef = useRef<SVGPathElement>(null);

  useEffect(() => {
    const path = pathRef.current;
    if (!path) return;

    const length = path.getTotalLength();

    // Initial setup
    path.style.strokeDasharray = `${length}`;
    path.style.strokeDashoffset = `${length}`;
    path.style.transition = 'none';

    // Trigger animation
    setTimeout(() => {
      path.style.transition = `stroke-dashoffset ${duration}ms cubic-bezier(0.25, 0.46, 0.45, 0.94)`;
      path.style.strokeDashoffset = '0';
    }, delay);

    return () => {
      path.style.transition = 'none';
    };
  }, [duration, delay]);

  return (
    <path
      ref={pathRef}
      d={pathData}
      stroke="currentColor"
      strokeWidth="2"
      fill="none"
      strokeLinecap="round"
      strokeLinejoin="round"
    />
  );
};
```

#### 2. Advanced Morphing

```typescript
import { gsap } from 'gsap';
import { MorphSVGPlugin } from 'gsap/MorphSVGPlugin';

gsap.registerPlugin(MorphSVGPlugin);

const MorphingIcon = ({
  isActive,
  paths
}: {
  isActive: boolean;
  paths: [string, string];
}) => {
  const pathRef = useRef<SVGPathElement>(null);

  useEffect(() => {
    if (!pathRef.current) return;

    gsap.to(pathRef.current, {
      morphSVG: isActive ? paths[1] : paths[0],
      duration: 0.4,
      ease: "power2.inOut"
    });
  }, [isActive, paths]);

  return (
    <svg viewBox="0 0 24 24" className="w-6 h-6">
      <path
        ref={pathRef}
        d={paths[0]}
        fill="currentColor"
      />
    </svg>
  );
};
```

## Motion (Framer Motion)

### Advanced Configuration

```typescript
import {
  motion,
  AnimatePresence,
  useAnimation,
  useInView,
  useScroll,
  useTransform,
  MotionConfig,
  LazyMotion,
  domAnimation,
  m
} from 'framer-motion';

// Optimized global configuration with LazyMotion
const MotionProvider = ({ children }: { children: React.ReactNode }) => (
  <LazyMotion features={domAnimation} strict>
    <MotionConfig
      transition={{
        type: "spring",
        stiffness: 300,
        damping: 30,
        mass: 0.8
      }}
      reducedMotion="user"
    >
      {children}
    </MotionConfig>
  </LazyMotion>
);

// Optimized component with m (lazy version)
const OptimizedComponent = () => (
  <m.div
    initial={{ opacity: 0, y: 20 }}
    animate={{ opacity: 1, y: 0 }}
    transition={{ duration: 0.4, ease: [0.25, 0.46, 0.45, 0.94] }}
  >
    Content
  </m.div>
);
```

### Advanced Variants and Orchestration 2024-2025

```typescript
// Hierarchical variant system with advanced orchestration
const containerVariants = {
  hidden: {
    opacity: 0,
    transition: {
      staggerChildren: 0.05,
      staggerDirection: -1,
      when: "afterChildren"
    }
  },
  visible: {
    opacity: 1,
    transition: {
      staggerChildren: 0.08,
      delayChildren: 0.1,
      when: "beforeChildren",
      type: "spring",
      stiffness: 400,
      damping: 25
    }
  }
};

// Variants with natural spring-based physics
const itemVariants = {
  hidden: {
    y: 60,
    opacity: 0,
    scale: 0.8,
    rotateX: -15,
    transition: {
      type: "spring",
      stiffness: 300,
      damping: 30
    }
  },
  visible: {
    y: 0,
    opacity: 1,
    scale: 1,
    rotateX: 0,
    transition: {
      type: "spring",
      stiffness: 400,
      damping: 25,
      mass: 0.8
    }
  }
};

// Conditional variants based on context
const adaptiveVariants = {
  hidden: (custom: { isReducedMotion: boolean; isMobile: boolean }) => ({
    opacity: 0,
    y: custom.isReducedMotion ? 0 : (custom.isMobile ? 20 : 40),
    transition: {
      duration: custom.isReducedMotion ? 0 : (custom.isMobile ? 0.3 : 0.5)
    }
  }),
  visible: (custom: { isReducedMotion: boolean; isMobile: boolean }) => ({
    opacity: 1,
    y: 0,
    transition: {
      type: custom.isReducedMotion ? "tween" : "spring",
      stiffness: custom.isMobile ? 200 : 300,
      damping: custom.isMobile ? 20 : 25
    }
  })
};
```

### Micro-interactions and Advanced Gestures

```typescript
import { useDragControls, PanInfo, useMotionValue, useTransform } from 'framer-motion';

// Hook for intelligent micro-interactions
const useSmartInteractions = () => {
  const [prefersReducedMotion] = useMediaQuery('(prefers-reduced-motion: reduce)');
  const [isTouchDevice] = useMediaQuery('(hover: none)');

  const getInteractionConfig = useCallback(() => ({
    hover: prefersReducedMotion ? {} : {
      scale: isTouchDevice ? 1 : 1.02,
      transition: { type: "spring", stiffness: 400, damping: 25 }
    },
    tap: {
      scale: 0.98,
      transition: { type: "spring", stiffness: 600, damping: 30 }
    }
  }), [prefersReducedMotion, isTouchDevice]);

  return { getInteractionConfig, prefersReducedMotion, isTouchDevice };
};

// Advanced card component with gestures
const AdvancedDraggableCard = ({
  onSwipe,
  children
}: {
  onSwipe?: (direction: 'left' | 'right') => void;
  children: React.ReactNode;
}) => {
  const dragControls = useDragControls();
  const [isDragging, setIsDragging] = useState(false);
  const { getInteractionConfig } = useSmartInteractions();

  const x = useMotionValue(0);
  const rotate = useTransform(x, [-200, 0, 200], [-15, 0, 15]);
  const opacity = useTransform(x, [-200, -100, 0, 100, 200], [0.5, 0.8, 1, 0.8, 0.5]);

  const handleDragEnd = (event: MouseEvent | TouchEvent | PointerEvent, info: PanInfo) => {
    const threshold = 100;
    const velocity = Math.abs(info.velocity.x);
    const offset = info.offset.x;

    if (velocity > 500 || Math.abs(offset) > threshold) {
      const direction = offset > 0 ? 'right' : 'left';
      onSwipe?.(direction);

      // Animate out
      animate(x, direction === 'right' ? 300 : -300, {
        type: "spring",
        stiffness: 300,
        damping: 30
      });
    } else {
      // Snap back
      animate(x, 0, {
        type: "spring",
        stiffness: 400,
        damping: 40
      });
    }
  };

  return (
    <motion.div
      drag="x"
      dragControls={dragControls}
      dragConstraints={{ left: 0, right: 0 }}
      dragElastic={0.1}
      style={{ x, rotate, opacity }}
      onDragStart={() => setIsDragging(true)}
      onDragEnd={handleDragEnd}
      whileHover={getInteractionConfig().hover}
      whileTap={getInteractionConfig().tap}
      className={`relative p-6 bg-white rounded-xl shadow-lg cursor-grab ${
        isDragging ? 'cursor-grabbing z-10' : ''
      }`}
    >
      {children}

      {/* Visual swipe indicators */}
      <motion.div
        className="absolute inset-y-0 left-4 flex items-center"
        animate={{ opacity: isDragging ? 1 : 0 }}
      >
        <div className="w-2 h-8 bg-green-400 rounded-full" />
      </motion.div>

      <motion.div
        className="absolute inset-y-0 right-4 flex items-center"
        animate={{ opacity: isDragging ? 1 : 0 }}
      >
        <div className="w-2 h-8 bg-red-400 rounded-full" />
      </motion.div>
    </motion.div>
  );
};

// Button with simulated haptic feedback
const HapticButton = ({
  onClick,
  children,
  variant = 'primary'
}: {
  onClick: () => void;
  children: React.ReactNode;
  variant?: 'primary' | 'secondary';
}) => {
  const { getInteractionConfig } = useSmartInteractions();

  const handleClick = () => {
    // Simulate visual haptic feedback
    if (navigator.vibrate) {
      navigator.vibrate(10);
    }
    onClick();
  };

  return (
    <motion.button
      onClick={handleClick}
      whileHover={getInteractionConfig().hover}
      whileTap={getInteractionConfig().tap}
      className={`px-6 py-3 rounded-lg font-medium transition-colors ${
        variant === 'primary'
          ? 'bg-blue-500 text-white hover:bg-blue-600'
          : 'bg-gray-200 text-gray-900 hover:bg-gray-300'
      }`}
    >
      {children}
    </motion.button>
  );
};
```

## Performance and Optimization

### Performance Monitoring

```typescript
// Hook for FPS monitoring
const usePerformanceMonitor = () => {
  const [fps, setFps] = useState(60);
  const [isLowPerformance, setIsLowPerformance] = useState(false);
  const frameCountRef = useRef(0);
  const lastTimeRef = useRef(performance.now());

  useEffect(() => {
    let animationId: number;

    const measureFPS = () => {
      frameCountRef.current++;
      const currentTime = performance.now();

      if (currentTime - lastTimeRef.current >= 1000) {
        const currentFPS = frameCountRef.current;
        setFps(currentFPS);
        setIsLowPerformance(currentFPS < 30);

        frameCountRef.current = 0;
        lastTimeRef.current = currentTime;
      }

      animationId = requestAnimationFrame(measureFPS);
    };

    measureFPS();

    return () => {
      cancelAnimationFrame(animationId);
    };
  }, []);

  return { fps, isLowPerformance };
};

// Adaptive component based on performance
const AdaptiveAnimation = ({
  children,
  fallback
}: {
  children: React.ReactNode;
  fallback?: React.ReactNode;
}) => {
  const { isLowPerformance } = usePerformanceMonitor();
  const [reducedMotion] = useMediaQuery('(prefers-reduced-motion: reduce)');

  if (reducedMotion || isLowPerformance) {
    return <>{fallback || children}</>;
  }

  return <>{children}</>;
};
```

### Resource Optimization

```typescript
// Lazy loading for heavy animations
const LazyAnimation = lazy(() => import('./HeavyAnimation'));

// Object pool for reuse
class ObjectPool<T> {
  private pool: T[] = [];
  private createFn: () => T;
  private resetFn: (obj: T) => void;

  constructor(createFn: () => T, resetFn: (obj: T) => void, initialSize = 10) {
    this.createFn = createFn;
    this.resetFn = resetFn;

    for (let i = 0; i < initialSize; i++) {
      this.pool.push(createFn());
    }
  }

  get(): T {
    return this.pool.pop() || this.createFn();
  }

  release(obj: T): void {
    this.resetFn(obj);
    this.pool.push(obj);
  }
}

// Debounce for event-based animations
const useAnimationDebounce = (callback: () => void, delay: number) => {
  const timeoutRef = useRef<NodeJS.Timeout>();

  return useCallback(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    timeoutRef.current = setTimeout(callback, delay);
  }, [callback, delay]);
};
```

## Accessibility in Animations

### Implementation of prefers-reduced-motion

```typescript
// Hook to detect reduced motion preference
const useReducedMotion = () => {
  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);

  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
    setPrefersReducedMotion(mediaQuery.matches);

    const handleChange = (event: MediaQueryListEvent) => {
      setPrefersReducedMotion(event.matches);
    };

    mediaQuery.addEventListener('change', handleChange);
    return () => mediaQuery.removeEventListener('change', handleChange);
  }, []);

  return prefersReducedMotion;
};

// Accessibility-respectful component
const AccessibleAnimation = ({
  children,
  fallback,
  respectMotionPreference = true
}: {
  children: React.ReactNode;
  fallback?: React.ReactNode;
  respectMotionPreference?: boolean;
}) => {
  const prefersReducedMotion = useReducedMotion();

  if (respectMotionPreference && prefersReducedMotion) {
    return <>{fallback || children}</>;
  }

  return <>{children}</>;
};

// Accessible variants for Framer Motion
const accessibleVariants = {
  hidden: (prefersReducedMotion: boolean) => ({
    opacity: 0,
    y: prefersReducedMotion ? 0 : 20,
    transition: {
      duration: prefersReducedMotion ? 0 : 0.3
    }
  }),
  visible: (prefersReducedMotion: boolean) => ({
    opacity: 1,
    y: 0,
    transition: {
      duration: prefersReducedMotion ? 0 : 0.3,
      ease: "easeOut"
    }
  })
};
```

## Behavioral Rules for Cursor IDE

### Component Declaration Rules

```typescript
// ✅ CORRECT: Use function declarations, not React.FC
function AnimatedButton({ onClick, children }: {
  onClick: () => void;
  children: React.ReactNode;
}) {
  return (
    <motion.button
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
      onClick={onClick}
    >
      {children}
    </motion.button>
  );
}

// ❌ INCORRECT: Don't use React.FC
const AnimatedButton: React.FC<Props> = ({ onClick, children }) => {
  // ...
};
```

### Animation Implementation Rules

1. **Always use compositor-friendly properties**
   - Prefer `transform`, `opacity`, `filter`
   - Avoid `width`, `height`, `top`, `left`

2. **Implement reduced motion fallbacks**

   ```typescript
   const variants = {
     initial: { opacity: 0, y: prefersReducedMotion ? 0 : 20 },
     animate: { opacity: 1, y: 0 }
   };
   ```

3. **Use spring physics for natural movement**

   ```typescript
   const springConfig = {
     type: "spring",
     stiffness: 400,
     damping: 25,
     mass: 0.8
   };
   ```

4. **Optimize for performance**
   - Use `LazyMotion` for bundle size optimization
   - Implement object pooling for repeated animations
   - Monitor FPS and adapt accordingly

5. **Provide meaningful feedback**
   - Loading states should have personality
   - Micro-interactions should feel responsive
   - Error states should be clearly animated

### Code Organization Rules

1. **Separate animation logic from business logic**
2. **Create reusable animation hooks**
3. **Use consistent naming conventions**
4. **Document complex animation sequences**
5. **Test animations across different devices**

### Performance Thresholds

- **Target**: 60 FPS consistently
- **Acceptable**: 30 FPS minimum
- **Duration limits**:
  - Micro-interactions: 150ms
  - Transitions: 300ms
  - Complex sequences: 800ms max

### Accessibility Requirements

- Always respect `prefers-reduced-motion`
- Provide alternative feedback for animations
- Ensure animations don't interfere with screen readers
- Test with keyboard navigation
- Maintain focus management during animations

This comprehensive guide ensures animations are performant, accessible, and enhance user experience while following modern best practices and avoiding deprecated patterns like `React.FC`.
